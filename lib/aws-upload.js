'use strict'

// require dotenv and run load method
// this loads my env variables to a process.env object
require('dotenv').load()

// require file system module
const fs = require('fs')
const AWS = require('aws-sdk')
const mime = require('mime')
const path = require('path')
const crypto = require('crypto')

// create an instance of AWS.S3 object
const s3 = new AWS.S3()

const randomBytesPromise = function () {
  return new Promise((resolve, reject) => {
    // Generates cryptographically strong pseudo-random data.
    // The size argument is a number indicating the number of bytes to generate.
    // If a callback function is provided, the bytes are generated asynchronously
    // and the callback function is invoked with two arguments: err and buf
    // If an error occurs, err will be an Error object;
    // otherwise it is null.
    // The buf argument is a Buffer containing the generated bytes.
    // https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback
    crypto.randomBytes(16, function (error, buffer) {
      // If an error occurs, err will be an Error object;
      if (error) {
        reject(error)
      } else {
        // More on buffer
        // https://nodejs.org/api/buffer.html#buffer_buffer
        resolve(buffer.toString('hex'))
      }
    })
  })
}

// s3Upload accepts file options as a param and returns a promise,
// that resolved or rejected base on s3.upload response
const s3Upload = function (options) {
  // use node fs module to create a read stream
  // for our image file
  // https://www.sitepoint.com/basics-node-js-streams/
  // const stream = fs.createReadStream(options.originalname)
  const stream = fs.createReadStream(options.path)
  // use node mime module to get image mime type
  // https://www.npmjs.com/package/mime
  // const contentType = mime.lookup(options.originalname)
  const contentType = mime.lookup(options.path)
  // use node path module to get image extension (.jpg, .gif)
  // https://nodejs.org/docs/latest/api/path.html#path_path
  const ext = path.extname(options.path) // .png
  // const ext = path.extname(options.name)
  // const ext = mime.extension(contentType)

  // get current date, turn into ISO string, and split to access correctly formatted date
  const folder = new Date().toISOString().split('T')[0]

  // params required for `.upload` to work
  // more at documentation
  // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#upload-property
  const params = {
    ACL: 'public-read',
    Bucket: process.env.AWS_S3_BUCKET_NAME,
    Body: stream,
    Key: `${folder}/${options.name}${ext}`,
    ContentType: contentType
  }

  // return a promise object that is resolved or rejected,
  // based on the response from s3.upload
  return new Promise((resolve, reject) => {
    // pass correct params to `.upload`
    // and anonymous allback for handling response
    s3.upload(params, function (error, data) {
      if (error) {
        reject(error)
      } else {
        resolve(data)
      }
    })
  })
}

const awsUpload = function (options) {
  return randomBytesPromise()
    .then((buffer) => {
      // set file name to buffer that is returned from randomBytesPromise
      options.name = buffer
      // return file so it is passed as argument to s3Upload
      return options
    })
    .then(s3Upload)
    .catch(console.error)
}

module.exports = awsUpload
